---
author: "Daniel Sherwood"
layout: post
title: "Designing Data Intesive Applications - Chapter 11"
date: 2025-06-02 15:44:00 -0500
categories: python
lead: "Stream Processing"
---
**I have had** the incredible opportunity to participate in the *Coder's Study Group* located in my city. 
The other participants are incredibly intelligent and experienced. 
Their insights have helped bring the abstract down into a more practical and relatable realm. 
We are now on Chapter 11 - Streaming Data. 
It is nearly the final chapter. Possibly, the author intends to tie many concepts introduced previously into this chatper.
Although I usually take notes privately, here I will put them out into the public space. 

# Streaming Data

The world is full of *unbounded* data -- that is, data which arrives gradually and continuously over time.
This data is ingested via *stream processing*.
This chapter:

1. Examines how streams are represented, stored, and transmitted over a network
2. Investigates the relationship between streams and databases
3. Explores approaches/tools for processing, with the intention of building applications.

## Transmitting Event Streams

In the streaming world, an individual record is referred to as an event, which usually has a timestamp associated with it.
An event is generated by a producer (publisher/sender) and then processed by a consumer (subscriber/recipient). 
Events are collected in *topics* or *streams*.

### Messaging Systems

In the Publisher/Subscriber model, what happens when: 

1. Producers send messages faster than consumers can process them?
2. Are messages lost when a nodes goes offline?

#### Direct Messaging from producers to consumers

One method is to pass messages from producers to consumers via UDP. 
This method is not fault tolerant. 

#### Message Brokers

Alternative is to use a database which is optimized for datastreams (also known as *message broker* / *message queue* ). 
It's a server, which producers & consumers connect as clients.
Helpful because the issue of durability is moved to the broker and away from producers/consumers.

#### Message Brokers Compared to Databases

Messages brokers can participate in two phase commit. 
But: 

1. They do not keep data - it is deleted when after successful deliver to consumer
2. If buffering is required ( longer than expected queue, then degradation of performance occurs).
3. They do notify clients when data changes, but do not support arbitrary queries

#### Multiple Consumers

Two patterns of reading messages: 

1. Load Balancing - Each message is delivered to *one* of the consumers. 
2. Fan Out - Each message is delivered to *all* of the consumers. 

#### Acknowledgements and redelivery 

A consumer must explicitly say that it has finished processing a message before the broker can delete it.
If this acknowledgement is not given and a timeout is reached, then the broker tries again with a different consumer. 
This can result in less than sequential ordering of messages. 

To avoid this issue, use a separate queue per consumer ( not use load balancing? )

### Partitioned Logs

A consumer only starts receiving messages after it has been activated, it has no knowledge of prior data. 
Now consider the idea of combining durable databases with low-latency notification facilities? 
Welcome to log-based message brokers.

#### Using Logs For Message Storage



#### Logs Compared to Traditional Messaging

#### Consumer Offsets

#### Disk Space Usage

#### When Consumers Cannot Keep Up with Producers

#### Replaying Old Messages

## Databases and Streams

### Keeping Systems in Sync

### Change Data Capture

#### Implementing Change Data Capture

#### Initial Snapshot

#### Log Compaction 

#### API Support for Change Streams

### Event sourcing

#### Deriving Current State From the Event Log

#### Commands and Events

### State, Streams, and Immutability

(ooh a formula )

#### Advantages of Immutable Events

#### Deriving Several Views from the Same Event Log

#### Concurrency Control 

#### Limitations of Immutablity 

## Processing Streams

### Uses of Streams Processing

#### Complex Event Processing

#### Stream Analytics

#### Maintaining Materialized Views

#### Search on Streams

#### Message passing and RPC

### Reasoning about Time

#### Event Time Versus Processing Time

#### Knowing When You Are Ready 

#### Whose Clock Are You Using, Anyway?

#### Types of Windows

### Stream Joins

#### Stream-Stream Join (Window Join)

#### Stream-Table (Stream Enrichment)

#### Table-Table Join (Materialized View Maintenance)

#### Time-Dependence of Joins 

### Fault Tolerance

#### Microbatching and Checkpointing

#### Atomic Commit Revisited 

#### Idempotence

#### Rebuilding State After a Failure

## Summary
